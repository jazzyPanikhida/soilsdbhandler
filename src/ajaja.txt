use serde::{Deserialize, Serialize};
use std::fs;

//инициализация JSON


#[derive(Debug, Deserialize)]
struct interactiondata {
    faclist: Vec<String>,
    famodval: Hashmap<String, String>,
    emodval: Hashmap<String, String>
}

#[derive(Debug, Deserialize)]
struct factordata {
    factorname: String,
    facvalue: f64,
    expvalue: f64
}

//инициализация циферок факторов
//создание сетов с элементами расчета
//подмена значений по необходимости в рендже от чего то до чего

fn wemathin(optype) {   
    let e = (v[optype]);
    let ops = ['+', '-', '*', '/', '^'];
    let values: Vec<f64> = e.split(&ops).map(|v| v.trim().parse().unwrap()).collect();
    let operands: Vec<_> = e.matches(&ops).collect();
    
    let (&(mut curr), values) = values.split_first().unwrap();
    for (op, &value) in operands.into_iter().zip(values) {
        match op {
            "+" => { curr = curr + value },
            "-" => { curr = curr - value },
            "*" => { curr = curr * value },
            "/" => { curr = curr / value },
            "^" => { curr = pow(curr, value)},
            _ => unreachable!(),
        }
    }
};


fn upd(facname, facnamein, facval, optype) {
    match self.facnamein {
        self.facname => self.facval = wemathin(optype)
        _ => self.facval = self.facval
    }
}

//  for каждый эл-т JSON 
// let mut main=fval
//let mut temp = fval
//for каждый эл-т фактора
//расчет значения фактора через temp
//self.main=self.temp

//сохранение значений
//создание таблицы значений по 2 факторам с каждым элементом - продукт другого фактора
//рендер пикчи по значению одного из факторов